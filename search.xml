<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++代理类]]></title>
    <url>%2F2019%2F07%2F14%2FC%2B%2B%E4%BB%A3%E7%90%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言本次读书笔记为C++沉思录第五章, 介绍的是代理类, 代理类是句柄类的一种, 较为简单 代理类并不局限于C++语言, 是一种广泛的编程思想 面临的问题C++通过虚函数来实现的运行时多态, 但是我们在构建一个容器存储时(不管是内建类型还是自定义类型容器)只能获得编译时类型一致的元素值. 例如:std::vector&lt;T&gt;, 我们声明一个存储 T 类型的 vector, 但是有时实际中我们拥有很多继承于同一基类的派生类对象, 若是容器中只能包含相同类型的元素, 我们就无法在该容器中包含同一个基类不同派生类对象了 而我们能想到的一个经典办法就是: 存储指针; 不过存储指针必然伴随着内存管理的问题, 即如何得知指针指向的对象是否还存在 那么我们现在面临的问题就是: 当我们将继承和容器共用时, 要管理内存分配和把不同类型对象放入同一容器 解决办法所谓计算机领域的任何问题, 都能通过增加一个中间层来解决 代理类代理类(surrogate)就是做这样的工作: 让我们忽略正在处理的对象的准确类型. 代理类是句柄(handle)类中最简单的一种 现有如下例子: 123456789101112class Vehicle //基类&#123;public: virtual double weight() const = 0; virtual void start() = 0; // ...&#125;;//派生类class RoadVehicle : public Vehicle&#123; / * ... */ &#125;;class AutoVehicle : public RoadVehicle&#123; /* ... */&#125;;class Aircraft : public Vehicle &#123; / * ... */&#125;;class Helicopter : public Aircraft &#123; / * ... */&#125;; 首先, 我们给基类和所有派生类增加copy接口, 返回对应的确切类型 123456789101112131415161718192021222324252627class Vehicle&#123; public: virtual Vehicle * copy() const = 0; /**/&#125;; //Vehicle的派生类都自实现copy函数class Truck : public Vehicle&#123;public: Vehicle* copy() const &#123; return new Truck(*this); &#125; /**/&#125;; //同时也该增加一个虚析构函数：class Vehicle&#123; public： virtual double weight() const = 0; virtual void start() = 0; virtual Vehicle * copy() const = 0; virtual ~Vehicle() &#123;&#125; // ...&#125;; 代理类: 1234567891011121314151617181920212223242526272829303132333435363738class VehicleSurrogate&#123;public: VehicleSurrogate() //缺省构造函数空代理 : vp(NULL) &#123;&#125;; VehicleSurrogate(const Vehicle&amp; v) //针对所有继承自Vehicle的派生类 : vp(v.copy()) &#123;&#125;; ~VehicleSurrogate() &#123;&#125;; VehicleSurrogate(const VehicleSurrogate&amp; v) : vp(v.vp ? v.vp-&gt;copy() : NULL) &#123;&#125;; //v.vp非零检测 VehicleSurrogate&amp; operator=(const VehicleSurrogate&amp; v) &#123; if (this != &amp;v) // 确保没有将代理赋值给它自身 &#123; delete vp; vp = (v.vp ? v.vp-&gt;copy() : NULL); &#125; return *this; &#125;; //来自类Vehicle的操作 void start() &#123; if (vp == 0) throw &quot;empty VehicleSurrogate.start()&quot;; vp-&gt;start(); &#125;; double weight() const &#123; if(vp == 0) throw &quot;empty VehcileSurrogate.weight()&quot;; return vp-&gt;weight(); &#125; private: Vehicle* vp;&#125;; 总结代理类很好理解, 就是一种管理句柄的句柄类, 提供了一个中间层重点是要学习这种思想]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++沉思录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello My New World]]></title>
    <url>%2F2019%2F07%2F08%2FHello%20My%20World%2F</url>
    <content type="text"><![CDATA[路漫漫其修远兮]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
